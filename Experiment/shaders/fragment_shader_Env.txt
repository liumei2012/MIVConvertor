#version 300 es
precision highp float;
precision highp int;
out vec4 outColor; // name of the output variable

in vec2 interpolatedTexCoord;

//uniform sampler2D PDFConditional;
uniform sampler2D MyTex;
uniform sampler2D ColAvg; // min_filter="NEAREST" mag_filter="NEAREST"
uniform sampler2D PDFJoint; // min_filter="NEAREST" mag_filter="NEAREST"
uniform sampler2D CDFMarg; // min_filter="NEAREST" mag_filter="NEAREST"
uniform sampler2D CDFCon; // min_filter="NEAREST" mag_filter="NEAREST"

uniform int width;
uniform int height;
uniform int samples; // description="Number of samples" defaultval="256"
uniform bool debug; // description="Enable debugging of sampling locations" defaultval="false"


#define PI 3.1415926535897932384626433832795


// pixel to textureCoord 
float p2t(in float p, in int noOfPixels) {
   return (p + 0.5) / float(noOfPixels);
}

// round to nearest integer
int round2Integer(in float val) {
  return int(val + 0.5);
}




// convert texture coordinates to pixels
float t2p(in float t, in int noOfPixels) {
  return t * float(noOfPixels) - 0.5;
}

// from http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
// Hacker's Delight, Henry S. Warren, 2001
float radicalInverse(uint bits) {
  bits = (bits << 16u) | (bits >> 16u);
  bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
  bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
  bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
  bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
  return float(bits) * 2.3283064365386963e-10; // / 0x100000000
}

vec2 hammersley(uint n, uint N) {
  return vec2(float(n) / float(N), radicalInverse(n));
}

float halton(uint base, uint index) {
  float result = 0.0;
  float digitWeight = 1.0;
  while (index > 0u) {
	  digitWeight = digitWeight / float(base);
  	uint nominator = index % base; // compute the remainder with the modulo operation
	  result += float(nominator) * digitWeight;
  	index = index / base; 
  }
  return result;
}

// Hash Functions for GPU Rendering, Jarzynski et al.
// http://www.jcgt.org/published/0009/03/02/
vec3 random_pcg3d(uvec3 v) {
  v = v * 1664525u + 1013904223u;
  v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;
  v ^= v >> 16u;
  v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;
  return vec3(v) * (1.0/float(0xffffffffu));
}

vec3 sphericalEnvmapToDirection(vec2 tex) {
  float theta = PI * (1.0 - tex.t);
  float phi = 2.0 * PI * (0.5 - tex.s);
  return vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
}

vec2 directionToSphericalEnvmap(vec3 dir) {
  float phi = atan(dir.y, dir.x);
  float theta = acos(dir.z);
  float s = 0.5 - phi / (2.0 * PI);
  float t = 1.0 - theta / PI;
  return vec2(s, t);
}

mat3 getNormalFrame(in vec3 normal) {
  vec3 someVec = vec3(1.0, 0.0, 0.0);
  float dd = dot(someVec, normal);
  vec3 tangent = vec3(0.0, 1.0, 0.0);
  if(1.0 - abs(dd) > 1e-6) {
    tangent = normalize(cross(someVec, normal));
  }
  vec3 bitangent = cross(normal, tangent);
  return mat3(tangent, bitangent, normal);
}

float fill(float sdf) {
  return clamp(0.5 - sdf / fwidth(sdf), 0.0, 1.0);
}

float circle(vec2 pos, vec2 center, float radius) {
  return length(pos - center) - radius;
}


vec3 prefilterEnvMapDiffuse(in sampler2D envmapSampler, in vec2 tex) {
  float px = t2p(tex.x, width);
  float py = t2p(tex.y, height);
  
  vec3 normal = sphericalEnvmapToDirection(tex);
  vec3 result = vec3(0.0);
  uint N = uint(samples);
  for(uint n = 1u; n <= N; n++) {
    vec2 random = vec2(halton(2u, n), halton(3u, n));
    float sampleY = texture(CDFMarg, vec2(0.5, random.y)).r;
    float sampleX = texture(CDFCon, vec2(random.x, sampleY)).r;
    vec2 sampleLocation = vec2(sampleX, sampleY);
    
    if(debug) {
      result.r += fill(circle(tex, sampleLocation, 0.003));
    } else {
      vec3 radiance = texture(envmapSampler, sampleLocation).rgb;
      float pdf = texture(PDFJoint, sampleLocation).r;
      vec3 posWorld = sphericalEnvmapToDirection(sampleLocation);
      float cosTheta = dot(normal, posWorld);
      if(cosTheta > 0.0 && pdf > 0.0) {
        float theta = PI * (1.0 - sampleLocation.t);
        result += 2.0 * PI * radiance * cosTheta * sin(theta) / pdf;
		
      }
    }
  }
  if(debug) {
    vec3 background = min(texture(envmapSampler, tex).rgb, 0.2);
    result = mix(background, result, result.r);
  } else {
    result = result / float(N);
  }
  return result;
}

void main() {
  
  // Env samp
    vec3 texColor = prefilterEnvMapDiffuse(MyTex, interpolatedTexCoord).xyz;
	//vec3 texColor = texture(MyTex, interpolatedTexCoord).rgb;
	//vec3 texColor = vec3(interpolatedTexCoord.r, interpolatedTexCoord.g, 0.0);
    outColor.rgb = texColor;
    outColor.a = 1.0;
  
}
