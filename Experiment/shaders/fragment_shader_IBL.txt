#version 300 es
precision highp float;
precision highp int;
out vec4 outColor;

in vec2 tc;
in vec3 wfn;
in vec3 vertPos;
in vec3 cPosition;

uniform sampler2D MIVBackgroundGuide;
uniform sampler2D baseColorTexture;
uniform sampler2D MyTex;
uniform sampler2D envmapDiffuse; // min_filter="NEAREST" mag_filter="NEAREST"
uniform sampler2D envmapSpecularLevel5; // min_filter="NEAREST" mag_filter="NEAREST"
uniform sampler2D brdfIntegrationMap;

uniform vec3 cameraPosition;
uniform mat4 meshTransform; // mesh transformation
uniform mat4 uView;
uniform float reflectance;
uniform float metallic;
uniform float roughness;
uniform bool IsBackGroundGuide;
uniform bool IsDepth;
uniform bool IsEnvLight;
vec3 rgb2lin(vec3 rgb) { // sRGB to linear approximation
  return pow(rgb, vec3(2.2));
}

vec3 lin2rgb(vec3 lin) { // linear to sRGB approximation
  return pow(lin, vec3(1.0 / 2.2));
}

#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_2PI 0.15915494309189535

#define PI 3.1415926535897932384626433832795

vec2 directionToSphericalEnvmap(vec3 dir) {

    float phi   = atan(dir.z, dir.x);      
    float theta = acos(clamp(dir.y, -1.0, 1.0)); 

    float s = phi / (2.0 * PI) + 0.5;      
    float t = 1.0 - theta / PI;  

    return vec2(s, t);
}

// The exporter does currently not support saving the mipmap levels of an input image.
// Therefore, all six levels are added as separate sampler2D uniform variables and
// the level interpolation is performed with the following code
vec3 myTextureLodExportReplacement(vec2 uv, float level) {
  
  //if(level < 0.0) {
  //  return texture(envmapSpecularLevel0, uv).rgb;
  //} else if(level >= 0.0 && level < 1.0) {
  //  vec3 a = texture(envmapSpecularLevel0, uv).rgb;
  //  vec3 b = texture(envmapSpecularLevel1, uv).rgb;
  //  return mix(a, b, level);
  //} else if(level >= 1.0 && level < 2.0) {
  //  vec3 a = texture(envmapSpecularLevel1, uv).rgb;
  //  vec3 b = texture(envmapSpecularLevel2, uv).rgb;
  //  return mix(a, b, level - 1.0);
  //} else if(level >= 2.0 && level < 3.0) {
  //  vec3 a = texture(envmapSpecularLevel2, uv).rgb;
  //  vec3 b = texture(envmapSpecularLevel3, uv).rgb;
  //  return mix(a, b, level - 2.0);
  //} else if(level >= 3.0 && level < 4.0) {
  //  vec3 a = texture(envmapSpecularLevel3, uv).rgb;
  //  vec3 b = texture(envmapSpecularLevel4, uv).rgb;
 //   return mix(a, b, level - 3.0);
  //} else if(level >= 4.0 && level <= 5.0) {
   // vec3 a = texture(envmapSpecularLevel4, uv).rgb;
   // vec3 b = texture(envmapSpecularLevel5, uv).rgb;
   // return mix(b, a, level - 4.0);
  //}
  
  return texture(envmapSpecularLevel5, uv).rgb;
}

// adapted from "Real Shading in Unreal Engine 4", Brian Karis, Epic Games
vec3 specularIBL(vec3 F0, float roughness, vec3 N, vec3 V) {
  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = reflect(-V, N);
  vec2 uv = directionToSphericalEnvmap(R);
  vec3 T1 = texture(envmapSpecularLevel5, uv).rgb;
  vec4 brdfIntegration = texture(brdfIntegrationMap, vec2(NoV, roughness));
  vec3 T2 = (F0 * brdfIntegration.x + brdfIntegration.y);
  return T1 * T2 ;
}

vec3 renderMesh() {
  vec3 baseCol = rgb2lin(texture(baseColorTexture, tc).rgb);
  //vec3 baseCol = vec3(0.5, 0.5, 0.5);
  vec3 viewDir = normalize(cameraPosition - vertPos);

  vec3 n = normalize(wfn);
  
  vec3 radiance = vec3(0.0, 0.0, 0.0);
  
  // compute F0
  vec3 f0 = vec3(0.16 * (reflectance * reflectance));
  f0 = mix(f0, baseCol, metallic);
  
  // image-based lighting (diffuse part)
  vec2 envUV = directionToSphericalEnvmap(n.xyz);

  radiance += baseCol * texture(envmapDiffuse, envUV).rgb;

  // image-based lighting (specular part)
  radiance +=  specularIBL(f0, roughness, n, viewDir);
  if(IsEnvLight)
  {
	return lin2rgb(radiance);
  }
  else{
	return lin2rgb(baseCol);
  }
  
}

void main() 
{
	
  if(!IsBackGroundGuide)
  {
	if(IsDepth)
	{
		float camdist = sqrt( (cPosition.x) * (cPosition.x) + (cPosition.y) * (cPosition.y) + (cPosition.z) * (cPosition.z) );
		float range = (1.0 / (camdist) - 1.0 / 25.0) / 1.96;
		outColor.rgb = vec3(range,range,range);
	}
	else
	{
		outColor.rgb = renderMesh();
	}
  
  }
  else
  {
	outColor.rgb = texture(MIVBackgroundGuide, tc).rgb;
  }

  outColor.a = 1.0;
    
}
