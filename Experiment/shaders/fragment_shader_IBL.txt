#version 300 es
precision highp float;
precision highp int;
out vec4 outColor;

in vec2 tc;
in vec3 wfn;
in vec3 vertPos;
in vec3 cPosition;

uniform sampler2D MIVBackgroundGuide;
uniform sampler2D baseColorTexture;
uniform sampler2D MyTex;
uniform sampler2D envmapDiffuse; // min_filter="NEAREST" mag_filter="NEAREST"
uniform sampler2D envmapSpecularLevel5; // min_filter="NEAREST" mag_filter="NEAREST"
uniform sampler2D brdfIntegrationMap;

uniform float irradiPerp; 
uniform vec3 cameraPosition;
uniform mat4 meshTransform; // mesh transformation
uniform mat4 uView;
uniform float reflectance;
uniform float metallic;
uniform bool IsBackGroundGuide;
uniform bool IsDepth;
vec3 rgb2lin(vec3 rgb) { // sRGB to linear approximation
  return pow(rgb, vec3(2.2));
}

vec3 lin2rgb(vec3 lin) { // linear to sRGB approximation
  return pow(lin, vec3(1.0 / 2.2));
}

#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_2PI 0.15915494309189535


float roughnessToShininess( const in float roughness ) {
	return pow(1000.0, 1.0-roughness);
}



vec3 fresnelSchlick(float cosTheta, vec3 F0) {
  return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float D_GGX(float NoH, float roughness) {
  float alpha = roughness * roughness;
  float alpha2 = alpha * alpha;
  float NoH2 = NoH * NoH;
  float b = (NoH2 * (alpha2 - 1.0) + 1.0);
  return alpha2 * RECIPROCAL_PI / (b * b);
}


float G1_GGX_Schlick(float NoV, float roughness) {
  float alpha = roughness * roughness;
  float k = alpha / 2.0;
  return max(NoV, 0.001) / (NoV * (1.0 - k) + k);
}

float G_Smith(float NoV, float NoL, float roughness) {
  return G1_GGX_Schlick(NoL, roughness) * G1_GGX_Schlick(NoV, roughness);
}

float fresnelSchlick90(float cosTheta, float F0, float F90) {
  return F0 + (F90 - F0) * pow(1.0 - cosTheta, 5.0);
} 

float disneyDiffuseFactor(float NoV, float NoL, float VoH, float roughness) {
  float alpha = roughness * roughness;
  float F90 = 0.5 + 2.0 * alpha * VoH * VoH;
  float F_in = fresnelSchlick90(NoL, 1.0, F90);
  float F_out = fresnelSchlick90(NoV, 1.0, F90);
  return F_in * F_out;
}




#define PI 3.1415926535897932384626433832795

vec2 directionToSphericalEnvmap(vec3 dir) {

    float phi   = atan(dir.z, dir.x);      
    float theta = acos(clamp(dir.y, -1.0, 1.0)); 

    float s = phi / (2.0 * PI) + 0.5;      
    float t = 1.0 - theta / PI;  

    return vec2(s, t);
}

// The exporter does currently not support saving the mipmap levels of an input image.
// Therefore, all six levels are added as separate sampler2D uniform variables and
// the level interpolation is performed with the following code
vec3 myTextureLodExportReplacement(vec2 uv, float level) {
  
  //if(level < 0.0) {
  //  return texture(envmapSpecularLevel0, uv).rgb;
  //} else if(level >= 0.0 && level < 1.0) {
  //  vec3 a = texture(envmapSpecularLevel0, uv).rgb;
  //  vec3 b = texture(envmapSpecularLevel1, uv).rgb;
  //  return mix(a, b, level);
  //} else if(level >= 1.0 && level < 2.0) {
  //  vec3 a = texture(envmapSpecularLevel1, uv).rgb;
  //  vec3 b = texture(envmapSpecularLevel2, uv).rgb;
  //  return mix(a, b, level - 1.0);
  //} else if(level >= 2.0 && level < 3.0) {
  //  vec3 a = texture(envmapSpecularLevel2, uv).rgb;
  //  vec3 b = texture(envmapSpecularLevel3, uv).rgb;
  //  return mix(a, b, level - 2.0);
  //} else if(level >= 3.0 && level < 4.0) {
  //  vec3 a = texture(envmapSpecularLevel3, uv).rgb;
  //  vec3 b = texture(envmapSpecularLevel4, uv).rgb;
 //   return mix(a, b, level - 3.0);
  //} else if(level >= 4.0 && level <= 5.0) {
   // vec3 a = texture(envmapSpecularLevel4, uv).rgb;
   // vec3 b = texture(envmapSpecularLevel5, uv).rgb;
   // return mix(b, a, level - 4.0);
  //}
  
  return texture(envmapSpecularLevel5, uv).rgb;
}

// adapted from "Real Shading in Unreal Engine 4", Brian Karis, Epic Games
vec3 specularIBL(vec3 F0, float roughness, vec3 N, vec3 V) {
  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = reflect(-V, N);
  vec2 uv = directionToSphericalEnvmap(R);
  vec3 T1 = texture(envmapSpecularLevel5, uv).rgb;
  vec4 brdfIntegration = texture(brdfIntegrationMap, vec2(NoV, roughness));
  vec3 T2 = (F0 * brdfIntegration.x + brdfIntegration.y);
  return T1 + T2 ;
}

vec3 renderMesh() {
  //vec3 baseCol = rgb2lin(texture(baseColorTexture, tc).rgb);
  vec3 baseCol = vec3(0.0,0.0,0.0);
  float roughness = 0.9;
  vec3 viewDir = normalize(cameraPosition - vertPos);
  //vec4 emission = texture(emissionTexture, tc);
  vec3 n = normalize(wfn);
  
  mat4 mNormal = transpose(inverse( uView * meshTransform));
  vec4 wNormal = vec4(vec3(mNormal * vec4(n, 0.0)).xyz , 1.0) ;
  
  vec3 radiance = vec3(0.0, 0.0, 0.0);
  
  // compute F0
  vec3 f0 = vec3(0.001 * (reflectance * reflectance));
  f0 = mix(f0, baseCol, metallic);
  
  // image-based lighting (diffuse part)
  vec2 envUV = directionToSphericalEnvmap(n.xyz);

  vec3 rhoD = (1.0 - metallic) * baseCol;
  //rhoD *= vec3(1.0) - f0; // optionally
  radiance =  texture(envmapDiffuse, envUV).rgb;
  
  //radiance = vec3(n.x, n.y, n.z);
  
  // image-based lighting (specular part)
  radiance =  specularIBL(f0, roughness, n, viewDir);
  
  return (radiance);
}

void main() 
{
	
  if(!IsBackGroundGuide)
  {
	if(IsDepth)
	{
		float camdist = sqrt( (cPosition.x) * (cPosition.x) + (cPosition.y) * (cPosition.y) + (cPosition.z) * (cPosition.z) );
		float range = (1.0 / (camdist) - 1.0 / 25.0) / 1.96;
		outColor.rgb = vec3(range,range,range);
	}
	else
	{
		outColor.rgb = renderMesh();
		//outColor.rgb = vec3(1.0, 0.0, 0.0);
	}
  
  }
  else
  {
	outColor.rgb = texture(MIVBackgroundGuide, tc).rgb;
  }

  outColor.a = 1.0;
    
}
