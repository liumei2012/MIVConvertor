#version 300 es
precision highp float;
precision highp int;
out vec4 outColor;

in vec2 tc; // texture coordinate of pixel (interpolated)
in vec3 wfn; // fragment normal of pixel in world space (interpolated)
in vec3 vertPos; // fragment vertex position in world space (interpolated)

uniform sampler2D baseColorTexture; // description="albedo for dielectrics or F0 for metals"
uniform sampler2D MyTex; // min_filter="LINEAR" mag_filter="LINEAR" wrap_s="REPEAT" wrap_t="REPEAT"
uniform sampler2D envmapDiffuse; // min_filter="LINEAR" mag_filter="LINEAR"
uniform sampler2D envmapSpecularLevel5; // min_filter="LINEAR" mag_filter="LINEAR"
uniform sampler2D brdfIntegrationMap; // min_filter="LINEAR" mag_filter="LINEAR"
uniform int mipLevelCount; // description="number of usable mipmap levels in envmapSpecular" defaultval ="5"
uniform float metallic; // description="metallic parameter, 0.0 for dielectrics, 1.0 for metals" defaultval ="0.0"
uniform float reflectance; // description="Fresnel reflectance for dielectrics in the range [0.0, 1.0]" defaultval ="0.5"
uniform vec4 lightColor; // description="color of light" defaultval="1.0, 1.0, 1.0, 1.0"
uniform float irradiPerp; // description="irradiance in perpendicular direction" defaultval="10.0"
uniform vec3 cameraPosition; // camera position in world space
uniform int gsnMeshGroup;

vec3 rgb2lin(vec3 rgb) { // sRGB to linear approximation
  return pow(rgb, vec3(2.2));
}

vec3 lin2rgb(vec3 lin) { // linear to sRGB approximation
  return pow(lin, vec3(1.0 / 2.2));
}

#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_2PI 0.15915494309189535


float roughnessToShininess( const in float roughness ) {
	return pow(1000.0, 1.0-roughness);
}



vec3 fresnelSchlick(float cosTheta, vec3 F0) {
  return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float D_GGX(float NoH, float roughness) {
  float alpha = roughness * roughness;
  float alpha2 = alpha * alpha;
  float NoH2 = NoH * NoH;
  float b = (NoH2 * (alpha2 - 1.0) + 1.0);
  return alpha2 * RECIPROCAL_PI / (b * b);
}

float G1_GGX_Schlick(float NoV, float roughness) {
  float alpha = roughness * roughness;
  float k = alpha / 2.0;
  return max(NoV, 0.001) / (NoV * (1.0 - k) + k);
}

float G_Smith(float NoV, float NoL, float roughness) {
  return G1_GGX_Schlick(NoL, roughness) * G1_GGX_Schlick(NoV, roughness);
}

float fresnelSchlick90(float cosTheta, float F0, float F90) {
  return F0 + (F90 - F0) * pow(1.0 - cosTheta, 5.0);
} 

float disneyDiffuseFactor(float NoV, float NoL, float VoH, float roughness) {
  float alpha = roughness * roughness;
  float F90 = 0.5 + 2.0 * alpha * VoH * VoH;
  float F_in = fresnelSchlick90(NoL, 1.0, F90);
  float F_out = fresnelSchlick90(NoV, 1.0, F90);
  return F_in * F_out;
}




#define PI 3.1415926535897932384626433832795

vec2 directionToSphericalEnvmap(vec3 dir) {
  float phi = atan(dir.y, dir.x);
  float theta = acos(dir.z);
  float s = 0.5 - phi / (2.0 * PI);
  float t = 1.0 - theta / PI;
  return vec2(s, t);
}

// The exporter does currently not support saving the mipmap levels of an input image.
// Therefore, all six levels are added as separate sampler2D uniform variables and
// the level interpolation is performed with the following code
vec3 myTextureLodExportReplacement(vec2 uv, float level) {
  
  //if(level < 0.0) {
  //  return texture(envmapSpecularLevel0, uv).rgb;
  //} else if(level >= 0.0 && level < 1.0) {
  //  vec3 a = texture(envmapSpecularLevel0, uv).rgb;
  //  vec3 b = texture(envmapSpecularLevel1, uv).rgb;
  //  return mix(a, b, level);
  //} else if(level >= 1.0 && level < 2.0) {
  //  vec3 a = texture(envmapSpecularLevel1, uv).rgb;
  //  vec3 b = texture(envmapSpecularLevel2, uv).rgb;
  //  return mix(a, b, level - 1.0);
  //} else if(level >= 2.0 && level < 3.0) {
  //  vec3 a = texture(envmapSpecularLevel2, uv).rgb;
  //  vec3 b = texture(envmapSpecularLevel3, uv).rgb;
  //  return mix(a, b, level - 2.0);
  //} else if(level >= 3.0 && level < 4.0) {
  //  vec3 a = texture(envmapSpecularLevel3, uv).rgb;
  //  vec3 b = texture(envmapSpecularLevel4, uv).rgb;
 //   return mix(a, b, level - 3.0);
  //} else if(level >= 4.0 && level <= 5.0) {
   // vec3 a = texture(envmapSpecularLevel4, uv).rgb;
   // vec3 b = texture(envmapSpecularLevel5, uv).rgb;
   // return mix(b, a, level - 4.0);
  //}
  
  return texture(envmapSpecularLevel5, uv).rgb;
}

// adapted from "Real Shading in Unreal Engine 4", Brian Karis, Epic Games
vec3 specularIBL(vec3 F0, float roughness, vec3 N, vec3 V) {
  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = reflect(-V, N);
  vec2 uv = directionToSphericalEnvmap(R);
  vec3 T1 = myTextureLodExportReplacement(uv, roughness * float(mipLevelCount));
  vec4 brdfIntegration = texture(brdfIntegrationMap, vec2(NoV, roughness));
  vec3 T2 = (F0 * brdfIntegration.x + brdfIntegration.y);
  return T1 * T2;
  //return T1;
}

vec3 renderMesh() {
  vec3 baseCol = rgb2lin(texture(baseColorTexture, tc).rgb);
  
  float roughness = 0.0;

  vec3 viewDir = normalize(cameraPosition - vertPos);
  vec3 n = normalize(wfn);

  n = vec3((wfn.x + 1.0)*0.5, (wfn.y + 1.0)*0.5, (wfn.z + 1.0)*0.5);

  vec3 radiance = vec3(0.0,0.0,0.0);
  
  // compute F0
  vec3 f0 = vec3(0.01 * (reflectance * reflectance));
  f0 = mix(f0, baseCol, metallic);
  
  // image-based lighting (diffuse part)
  vec2 envUV = directionToSphericalEnvmap(n);
  vec3 rhoD = (1.0) * baseCol;
  
  //rhoD *= vec3(1.0) - f0; // optionally
  baseCol += rhoD * texture(envmapDiffuse, envUV).rgb;
  
  // image-based lighting (specular part)
  baseCol += specularIBL(f0, roughness, n, viewDir);

  return lin2rgb(baseCol);
  //return lin2rgb(rhoD * texture(envmapDiffuse, envUV).rgb);
}

void main() {
  if(gsnMeshGroup == 0) {
    //outColor.rgb = renderMesh();
	//outColor.rgb = vec3(1.0, 0.0, 0.0);
	outColor.rgb = texture(envmapDiffuse, vec2(tc.x, tc.y)).rgb;
  }
  //if(gsnMeshGroup == 1) {
   // outColor.rgb = texture(envmapDiffuse, vec2(0.5 - tc.x, tc.y)).rgb;
  //}
  outColor.a = 1.0;
    
}
